#include <eepp/network/ctcpsocket.hpp>
#include <eepp/network/cipaddress.hpp>
#include <eepp/network/cpacket.hpp>
#include <eepp/network/platform/platformimpl.hpp>
#include <algorithm>
#include <cstring>

#ifdef _MSC_VER
	#pragma warning(disable : 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif

namespace
{
	// Define the low-level send/receive flags, which depend on the OS
	#if EE_PLATFORM == EE_PLATFORM_LINUX
		const int flags = MSG_NOSIGNAL;
	#else
		const int flags = 0;
	#endif
}

namespace EE { namespace Network {

cTcpSocket::cTcpSocket() :
	cSocket(Tcp)
{
}

unsigned short cTcpSocket::GetLocalPort() const {
	if (GetHandle() != Private::cSocketImpl::InvalidSocket()) {
		// Retrieve informations about the local end of the socket
		sockaddr_in address;
		Private::cSocketImpl::AddrLength size = sizeof(address);
		if (getsockname(GetHandle(), reinterpret_cast<sockaddr*>(&address), &size) != -1) {
			return ntohs(address.sin_port);
		}
	}

	// We failed to retrieve the port
	return 0;
}

cIpAddress cTcpSocket::GetRemoteAddress() const {
	if (GetHandle() != Private::cSocketImpl::InvalidSocket()) {
		// Retrieve informations about the remote end of the socket
		sockaddr_in address;
		Private::cSocketImpl::AddrLength size = sizeof(address);
		if (getpeername(GetHandle(), reinterpret_cast<sockaddr*>(&address), &size) != -1) {
			return cIpAddress(ntohl(address.sin_addr.s_addr));
		}
	}

	// We failed to retrieve the address
	return cIpAddress::None;
}

unsigned short cTcpSocket::GetRemotePort() const {
	if (GetHandle() != Private::cSocketImpl::InvalidSocket()) {
		// Retrieve informations about the remote end of the socket
		sockaddr_in address;
		Private::cSocketImpl::AddrLength size = sizeof(address);
		if (getpeername(GetHandle(), reinterpret_cast<sockaddr*>(&address), &size) != -1) {
			return ntohs(address.sin_port);
		}
	}

	// We failed to retrieve the port
	return 0;
}

cSocket::Status cTcpSocket::Connect(const cIpAddress& remoteAddress, unsigned short remotePort, cTime timeout) {
	// Create the internal socket if it doesn't exist
	Create();

	// Create the remote address
	sockaddr_in address = Private::cSocketImpl::CreateAddress(remoteAddress.ToInteger(), remotePort);

	if (timeout <= cTime::Zero) {
		// ----- We're not using a timeout: just try to connect -----

		// Connect the socket
		if (::connect(GetHandle(), reinterpret_cast<sockaddr*>(&address), sizeof(address)) == -1)
			return Private::cSocketImpl::GetErrorStatus();

		// Connection succeeded
		return Done;
	} else {
		// ----- We're using a timeout: we'll need a few tricks to make it work -----

		// Save the previous blocking state
		bool blocking = IsBlocking();

		// Switch to non-blocking to enable our connection timeout
		if (blocking)
			SetBlocking(false);

		// Try to connect to the remote address
		if (::connect(GetHandle(), reinterpret_cast<sockaddr*>(&address), sizeof(address)) >= 0) {
			// We got instantly connected! (it may no happen a lot...)
			SetBlocking(blocking);
			return Done;
		}

		// Get the error status
		Status status = Private::cSocketImpl::GetErrorStatus();

		// If we were in non-blocking mode, return immediatly
		if (!blocking)
			return status;

		// Otherwise, wait until something happens to our socket (success, timeout or error)
		if (status == cSocket::NotReady) {
			// Setup the selector
			fd_set selector;
			FD_ZERO(&selector);
			FD_SET(GetHandle(), &selector);

			// Setup the timeout
			timeval time;
			time.tv_sec  = static_cast<long>(timeout.AsMicroseconds() / 1000000);
			time.tv_usec = static_cast<long>(timeout.AsMicroseconds() % 1000000);

			// Wait for something to write on our socket (which means that the connection request has returned)
			if (select(static_cast<int>(GetHandle() + 1), NULL, &selector, NULL, &time) > 0) {
				// At this point the connection may have been either accepted or refused.
				// To know whether it's a success or a failure, we must check the address of the connected peer
				if (GetRemoteAddress() != cIpAddress::None) {
					// Connection accepted
					status = Done;
				} else {
					// Connection refused
					status = Private::cSocketImpl::GetErrorStatus();
				}
			} else {
				// Failed to connect before timeout is over
				status = Private::cSocketImpl::GetErrorStatus();
			}
		}

		// Switch back to blocking mode
		SetBlocking(true);

		return status;
	}
}

void cTcpSocket::Disconnect() {
	// Close the socket
	Close();

	// Reset the pending packet data
	mPendingPacket = PendingPacket();
}

cSocket::Status cTcpSocket::Send(const void* data, std::size_t size) {
	// Check the parameters
	if (!data || (size == 0)) {
		eePRINTL( "Cannot send data over the network (no data to send)" );
		return Error;
	}

	// Loop until every byte has been sent
	int sent = 0;
	int sizeToSend = static_cast<int>(size);
	for (int length = 0; length < sizeToSend; length += sent) {
		// Send a chunk of data
		sent = ::send(GetHandle(), static_cast<const char*>(data) + length, sizeToSend - length, flags);

		// Check for errors
		if (sent < 0)
			return Private::cSocketImpl::GetErrorStatus();
	}

	return Done;
}

cSocket::Status cTcpSocket::Receive(void* data, std::size_t size, std::size_t& received) {
	// First clear the variables to fill
	received = 0;

	// Check the destination buffer
	if (!data) {
		eePRINTL( "Cannot receive data from the network (the destination buffer is invalid)" );
		return Error;
	}

	// Receive a chunk of bytes
	int sizeReceived = recv(GetHandle(), static_cast<char*>(data), static_cast<int>(size), flags);

	// Check the number of bytes received
	if (sizeReceived > 0) {
		received = static_cast<std::size_t>(sizeReceived);
		return Done;
	} else if (sizeReceived == 0) {
		return cSocket::Disconnected;
	} else {
		return Private::cSocketImpl::GetErrorStatus();
	}
}

cSocket::Status cTcpSocket::Send(cPacket& packet) {
	// TCP is a stream protocol, it doesn't preserve messages boundaries.
	// This means that we have to send the packet size first, so that the
	// receiver knows the actual end of the packet in the data stream.

	// We allocate an extra memory block so that the size can be sent
	// together with the data in a single call. This may seem inefficient,
	// but it is actually required to avoid partial send, which could cause
	// data corruption on the receiving end.

	// Get the data to send from the packet
	std::size_t size = 0;
	const void* data = packet.OnSend(size);

	// First convert the packet size to network byte order
	Uint32 packetSize = htonl(static_cast<Uint32>(size));
 
	// Allocate memory for the data block to send
	std::vector<char> blockToSend(sizeof(packetSize) + size);
 
	// Copy the packet size and data into the block to send
	std::memcpy(&blockToSend[0], &packetSize, sizeof(packetSize));
	if (size > 0)
		std::memcpy(&blockToSend[0] + sizeof(packetSize), data, size);

	// Send the data block
	return Send(&blockToSend[0], blockToSend.size());
}

cSocket::Status cTcpSocket::Receive(cPacket& packet)
{
	// First clear the variables to fill
	packet.Clear();

	// We start by getting the size of the incoming packet
	Uint32 packetSize = 0;
	std::size_t received = 0;
	if (mPendingPacket.SizeReceived < sizeof(mPendingPacket.Size)) {
		// Loop until we've received the entire size of the packet
		// (even a 4 byte variable may be received in more than one call)
		while (mPendingPacket.SizeReceived < sizeof(mPendingPacket.Size)) {
			char* data = reinterpret_cast<char*>(&mPendingPacket.Size) + mPendingPacket.SizeReceived;
			Status status = Receive(data, sizeof(mPendingPacket.Size) - mPendingPacket.SizeReceived, received);
			mPendingPacket.SizeReceived += received;

			if (status != Done)
				return status;
		}

		// The packet size has been fully received
		packetSize = ntohl(mPendingPacket.Size);
	} else {
		// The packet size has already been received in a previous call
		packetSize = ntohl(mPendingPacket.Size);
	}

	// Loop until we receive all the packet data
	char buffer[1024];
	while (mPendingPacket.Data.size() < packetSize) {
		// Receive a chunk of data
		std::size_t sizeToGet = eemin(static_cast<std::size_t>(packetSize - mPendingPacket.Data.size()), sizeof(buffer));
		Status status = Receive(buffer, sizeToGet, received);
		if (status != Done)
			return status;

		// Append it into the packet
		if (received > 0) {
			mPendingPacket.Data.resize(mPendingPacket.Data.size() + received);
			char* begin = &mPendingPacket.Data[0] + mPendingPacket.Data.size() - received;
			std::memcpy(begin, buffer, received);
		}
	}

	// We have received all the packet data: we can copy it to the user packet
	if (!mPendingPacket.Data.empty())
		packet.OnReceive(&mPendingPacket.Data[0], mPendingPacket.Data.size());

	// Clear the pending packet data
	mPendingPacket = PendingPacket();

	return Done;
}

cTcpSocket::PendingPacket::PendingPacket() :
	Size		(0),
	SizeReceived(0),
	Data		()
{
}

}}

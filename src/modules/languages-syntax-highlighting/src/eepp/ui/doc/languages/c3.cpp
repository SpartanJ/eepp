#include <eepp/ui/doc/languages/c3.hpp>
#include <eepp/ui/doc/syntaxdefinitionmanager.hpp>

namespace EE { namespace UI { namespace Doc { namespace Language {

SyntaxDefinition& addC3() {

	auto& sd = SyntaxDefinitionManager::instance()->add(

		{ "C3",
		  { "%.c3t?$" },
		  {
			  { { "//.-\n" }, "comment" },
			  { { "/%*", "%*/" }, "comment" },
			  { { "<%*", "%*>" }, "comment" },
			  { { "\"", "\"", "\\" }, "string" },
			  { { "'", "'", "\\" }, "string" },
			  { { "`", "`" }, "string" },
			  { { "(enum|interface|alias|struct|typedef)\\s+([A-Za-z][\\w_]*)" },
				{ "keyword", "keyword", "type" },
				"",
				SyntaxPatternMatchType::RegEx },
			  { { "^%s*(import)%s+([%a][%w_%:,%s]*)%f[@;\n]" },
				{ "normal", "keyword", "literal" } },
			  { { "^%s*(module)%s+([%a][%w_%:%s%{%},]*)%s*%f[@;\n]" },
				{ "normal", "keyword", "literal" } },
			  { { "(fn)%s+([%a][%w_]*%*?%\?\?)%s+([%a][%w_]*)%.([%a_][%w_]*)%f[%(]" },
				{ "normal", "keyword", "type", "type", "function" } },
			  { { "(macro)%s+([%a][%w_]*%*?%\?\?)%s+([%a][%w_]*)%.([%a_][%w_]*)%f[%(]" },
				{ "normal", "keyword", "type", "type", "function" } },
			  { { "(fn)%s+([%a][%w_]*%*?%\?\?)%s+([%a][%w_]*)%f[%(]" },
				{ "normal", "keyword", "type", "function" } },
			  { { "common_number_parser_ob" }, "number", "", SyntaxPatternMatchType::Parser },
			  { { "[%a_][%w_]*%f[(]" }, "function" },
			  { { "[<>~=+-*/%?]=" }, "operator" },
			  { { "%.%." }, "operator" },
			  { { "(#[%a][%w_]*)" }, "parameter" },
			  { { "(@)([%a][%w_]*)" }, { "normal", "operator", "keyword" } },
			  { { "%$?%$?[%a_][%w_]*" }, "symbol" },

		  },
		  {
			  { "continue", "keyword" },
			  { "asm", "keyword" },
			  { "default", "keyword" },
			  { "define", "keyword" },
			  { "attribute", "keyword" },
			  { "faultdef", "keyword" },
			  { "extern", "keyword" },
			  { "foreach", "keyword" },
			  { "union", "keyword" },
			  { "false", "literal" },
			  { "for", "keyword" },
			  { "while", "keyword" },
			  { "const", "keyword" },
			  { "null", "literal" },
			  { "else", "keyword" },
			  { "enum", "keyword" },
			  { "struct", "keyword" },
			  { "break", "keyword" },
			  { "if", "keyword" },
			  { "alias", "keyword" },
			  { "macro", "keyword" },
			  { "fault", "keyword" },
			  { "switch", "keyword" },
			  { "nextcase", "keyword" },
			  { "return", "keyword" },
			  { "var", "keyword" },
			  { "import", "keyword" },
			  { "tlocal", "keyword" },
			  { "try", "keyword" },
			  { "void", "keyword" },
			  { "static", "keyword" },
			  { "inline", "keyword" },
			  { "defer", "keyword" },
			  { "module", "keyword" },
			  { "assert", "keyword" },
			  { "typedef", "keyword" },
			  { "def", "keyword" },
			  { "catch", "keyword" },
			  { "true", "literal" },
			  { "local", "keyword" },
			  { "foreach_r", "keyword" },
			  { "fn", "keyword" },
			  { "case", "keyword" },
			  { "bitstruct", "keyword" },
			  { "interface", "keyword" },
			  { "attrdef", "keyword" },
			  { "distinct", "keyword" },
			  { "do", "keyword" },

			  { "anyfault", "type" },
			  { "int", "type" },
			  { "BigInt", "type" },
			  { "char", "type" },
			  { "isz", "type" },
			  { "bool", "type" },
			  { "long", "type" },
			  { "short", "type" },
			  { "float16", "type" },
			  { "any", "type" },
			  { "usz", "type" },
			  { "float128", "type" },
			  { "uptr", "type" },
			  { "double", "type" },
			  { "typeid", "type" },
			  { "ulong", "type" },
			  { "int128", "type" },
			  { "byte", "type" },
			  { "uint", "type" },
			  { "iptr", "type" },
			  { "ushort", "type" },
			  { "float", "type" },
			  { "uint128", "type" },
			  { "ichar", "type" },

			  { "String", "type" },
			  { "List", "type" },
			  { "File", "type" },
			  { "Path", "type" },

			  { "$alignof", "keyword" },
			  { "$assert", "keyword" },
			  { "$case", "keyword" },
			  { "$default", "keyword" },
			  { "$defined", "keyword" },
			  { "$echo", "keyword" },
			  { "$embed", "keyword" },
			  { "$exec", "keyword" },
			  { "$else", "keyword" },
			  { "$endfor", "keyword" },
			  { "$endforeach", "keyword" },
			  { "$endif", "keyword" },
			  { "$endswitch", "keyword" },
			  { "$eval", "keyword" },
			  { "$evaltype", "keyword" },
			  { "$error", "keyword" },
			  { "$extnameof", "keyword" },
			  { "$for", "keyword" },
			  { "$foreach", "keyword" },
			  { "$if", "keyword" },
			  { "$include", "keyword" },
			  { "$nameof", "keyword" },
			  { "$offsetof", "keyword" },
			  { "$qnameof", "keyword" },
			  { "$sizeof", "keyword" },
			  { "$stringify", "keyword" },
			  { "$switch", "keyword" },
			  { "$typefrom", "keyword" },
			  { "$typeof", "keyword" },
			  { "$vacount", "keyword" },
			  { "$vatype", "keyword" },
			  { "$vaconst", "keyword" },
			  { "$vaarg", "keyword" },
			  { "$vaexpr", "keyword" },
			  { "$vasplat", "keyword" },

			  { "@align", "type" },
			  { "@benchmark", "type" },
			  { "@bigendian", "type" },
			  { "@builtin", "type" },
			  { "@cdecl", "type" },
			  { "@deprecated", "type" },
			  { "@dynamic", "type" },
			  { "@export", "type" },
			  { "@extern", "type" },
			  { "@extname", "type" },
			  { "@inline", "type" },
			  { "@interface", "type" },
			  { "@littleendian", "type" },
			  { "@local", "type" },
			  { "@maydiscard", "type" },
			  { "@naked", "type" },
			  { "@nodiscard", "type" },
			  { "@noinit", "type" },
			  { "@noinline", "type" },
			  { "@noreturn", "type" },
			  { "@nostrip", "type" },
			  { "@obfuscate", "type" },
			  { "@operator", "type" },
			  { "@overlap", "type" },
			  { "@packed", "type" },
			  { "@priority", "type" },
			  { "@private", "type" },
			  { "@public", "type" },
			  { "@pure", "type" },
			  { "@reflect", "type" },
			  { "@section", "type" },
			  { "@stdcall", "type" },
			  { "@test", "type" },
			  { "@unused", "type" },
			  { "@used", "type" },
			  { "@veccall", "type" },
			  { "@wasm", "type" },
			  { "@weak", "type" },
			  { "@winmain", "type" },

			  { "$$BENCHMARK_FNS", "literal" },
			  { "$$BENCHMARK_NAMES", "literal" },
			  { "$$DATE", "literal" },
			  { "$$FILE", "literal" },
			  { "$$FILEPATH", "literal" },
			  { "$$FUNC", "literal" },
			  { "$$FUNCTION", "literal" },
			  { "$$LINE", "literal" },
			  { "$$LINE_RAW", "literal" },
			  { "$$MODULE", "literal" },
			  { "$$TEST_FNS", "literal" },
			  { "$$TEST_NAMES", "literal" },
			  { "$$TIME", "literal" },
		  },
		  "//",
		  {}

		} );

	sd.setFoldRangeType( FoldRangeType::Braces ).setFoldBraces( { { '{', '}' } } );
	sd.setBlockComment( { "/*", "*/" } );
	return sd;
}

}}}} // namespace EE::UI::Doc::Language
